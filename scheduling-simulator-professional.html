<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulateur d'Algorithmes d'Ordonnancement Temps R√©el</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #f5f5f5;
            padding: 15px;
            color: #333;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            padding: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            text-align: center;
            margin-bottom: 5px;
            font-size: 1.6em;
            color: #2c3e50;
            font-weight: normal;
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 20px;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .controls-section {
            background: #fafafa;
            padding: 15px;
            border: 1px solid #e0e0e0;
        }

        .control-row {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px;
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 5px;
            margin: 10px 0;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-group label {
            cursor: pointer;
            font-size: 0.85em;
            color: #856404;
            font-weight: 600;
            flex: 1;
        }

        label {
            font-weight: 500;
            color: #555;
            font-size: 0.85em;
            min-width: 100px;
        }

        input[type="number"] {
            padding: 6px 10px;
            border: 1px solid #ccc;
            font-size: 0.85em;
            width: 70px;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #3498db;
        }

        .button-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        button {
            padding: 8px 16px;
            border: 1px solid #bbb;
            background: white;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
            width: 100%;
        }

        button:hover:not(:disabled) {
            background: #f0f0f0;
            border-color: #999;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.primary {
            background: #3498db;
            color: white;
            border-color: #2980b9;
        }

        button.primary:hover:not(:disabled) {
            background: #2980b9;
        }

        button.success {
            background: #27ae60;
            color: white;
            border-color: #229954;
        }

        button.success:hover:not(:disabled) {
            background: #229954;
        }

        button.warning {
            background: #f39c12;
            color: white;
            border-color: #e67e22;
        }

        button.warning:hover:not(:disabled) {
            background: #e67e22;
        }

        button.danger {
            background: #e74c3c;
            color: white;
            border-color: #c0392b;
        }

        button.danger:hover:not(:disabled) {
            background: #c0392b;
        }

        .tasks-info {
            background: #fafafa;
            padding: 12px;
            border: 1px solid #e0e0e0;
            max-height: 400px;
            overflow-y: auto;
        }

        .tasks-info h3 {
            margin-bottom: 10px;
            font-size: 0.95em;
            color: #2c3e50;
            font-weight: 600;
        }

        .task-card {
            background: white;
            padding: 10px;
            margin-bottom: 8px;
            border-left: 4px solid;
            font-size: 0.8em;
        }

        .task-name {
            font-weight: bold;
            margin-bottom: 6px;
            font-size: 1em;
        }

        .task-detail {
            color: #666;
            margin: 3px 0;
            font-size: 0.9em;
        }

        .task-detail strong {
            color: #333;
            min-width: 70px;
            display: inline-block;
        }

        .utilization-info {
            background: #e8f5e9;
            border: 2px solid #4caf50;
            padding: 12px;
            margin-top: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .utilization-info.overload {
            background: #ffebee;
            border-color: #f44336;
        }

        .utilization-value {
            font-size: 1.3em;
            font-weight: bold;
            color: #2e7d32;
        }

        .utilization-info.overload .utilization-value {
            color: #c62828;
        }

        .schedulability-bounds {
            background: #f5f5f5;
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
            font-size: 0.85em;
        }

        .legend {
            background: #fafafa;
            padding: 10px;
            border: 1px solid #e0e0e0;
            font-size: 0.8em;
        }

        .legend h4 {
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .legend-items {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 25px;
            height: 15px;
            border: 1px solid #666;
            flex-shrink: 0;
        }

        .simulators-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .simulator-container {
            background: white;
            border: 1px solid #ddd;
        }

        .simulator-title {
            font-size: 1em;
            font-weight: 600;
            padding: 10px 15px;
            color: #2c3e50;
            background: #f9f9f9;
            border-bottom: 2px solid #3498db;
        }

        .gantt-chart {
            position: relative;
            background: white;
            border: 2px solid #333;
        }

        .gantt-row {
            display: flex;
            border-bottom: 1px solid #999;
            min-height: 40px;
            position: relative;
        }

        .gantt-row:last-child {
            border-bottom: none;
        }

        .task-label {
            width: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.85em;
            border-right: 2px solid #333;
            background: #f9f9f9;
            flex-shrink: 0;
        }

        .timeline-area {
            flex: 1;
            position: relative;
            background: linear-gradient(to right, transparent 0%, transparent calc(100% / var(--grid-columns) - 1px), #ddd calc(100% / var(--grid-columns) - 1px), #ddd calc(100% / var(--grid-columns)));
            background-size: calc(100% / var(--grid-columns)) 100%;
            overflow: hidden;
        }

        .task-block {
            position: absolute;
            height: 70%;
            top: 15%;
            background: #666;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75em;
            font-weight: bold;
            color: white;
            transition: left 0.1s linear, width 0.1s linear;
            opacity: 0.85;
        }

        .task-block.preempted {
            border: 3px dashed #ff9800;
            opacity: 0.7;
            border-right: 4px solid #ff9800;
            box-shadow: 2px 0 8px rgba(255, 152, 0, 0.4);
        }

        .task-block.resumed {
            border-left: 4px solid #ff9800;
            box-shadow: -2px 0 8px rgba(255, 152, 0, 0.4);
        }

        .task-block.executing {
            box-shadow: 0 0 15px rgba(52, 152, 219, 1), 0 0 30px rgba(52, 152, 219, 0.5);
            border: 3px solid #3498db;
            opacity: 1;
            z-index: 5;
            animation: pulse-glow 1s infinite;
        }

        .preemption-indicator {
            position: absolute;
            width: 4px;
            height: 100%;
            background: linear-gradient(to bottom, #ff9800, #ff6f00);
            z-index: 6;
            top: 0;
            box-shadow: 0 0 8px rgba(255, 152, 0, 0.8);
        }

        .preemption-indicator::before {
            content: '‚äó';
            position: absolute;
            top: 50%;
            left: -10px;
            transform: translateY(-50%);
            font-size: 1.5em;
            color: #ff9800;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(255, 152, 0, 0.8), 0 0 8px rgba(255, 152, 0, 0.4);
            animation: preemption-pulse 1.5s infinite;
        }

        @keyframes preemption-pulse {
            0%, 100% {
                transform: translateY(-50%) scale(1);
            }
            50% {
                transform: translateY(-50%) scale(1.2);
            }
        }

        @keyframes pulse-glow {
            0%, 100% {
                box-shadow: 0 0 15px rgba(52, 152, 219, 1), 0 0 30px rgba(52, 152, 219, 0.5);
            }
            50% {
                box-shadow: 0 0 20px rgba(52, 152, 219, 1), 0 0 40px rgba(52, 152, 219, 0.7);
            }
        }

        .deadline-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: red;
            z-index: 5;
        }

        .deadline-marker::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: -3px;
            width: 0;
            height: 0;
            border-left: 3px solid transparent;
            border-right: 3px solid transparent;
            border-bottom: 6px solid red;
        }

        .period-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: black;
            z-index: 4;
        }

        .period-marker::after {
            content: '';
            position: absolute;
            top: -4px;
            left: -3px;
            width: 0;
            height: 0;
            border-left: 3px solid transparent;
            border-right: 3px solid transparent;
            border-top: 6px solid black;
        }

        .time-axis {
            display: flex;
            border-top: 2px solid #333;
            background: #f9f9f9;
        }

        .time-label-spacer {
            width: 50px;
            border-right: 2px solid #333;
            flex-shrink: 0;
        }

        .time-labels {
            flex: 1;
            display: flex;
            position: relative;
        }

        .time-tick {
            flex: 1;
            text-align: center;
            padding: 5px 0;
            font-size: 0.75em;
            border-right: 1px solid #ddd;
            position: relative;
        }

        .time-tick:last-child {
            border-right: none;
        }

        .time-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: red;
            z-index: 10;
            pointer-events: none;
            transition: left 0.1s linear;
        }

        .stats-section {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            padding: 10px 15px;
            background: #fafafa;
            border-top: 1px solid #e0e0e0;
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            font-size: 0.7em;
            color: #7f8c8d;
            margin-bottom: 3px;
        }

        .stat-value {
            font-size: 1.1em;
            font-weight: 600;
            color: #2c3e50;
        }

        .explanation-panel {
            background: #fff9e6;
            border: 2px solid #f39c12;
            padding: 15px;
            margin-bottom: 15px;
        }

        .explanation-panel h4 {
            margin-bottom: 8px;
            color: #d68910;
            font-size: 0.95em;
        }

        .explanation-panel p {
            line-height: 1.5;
            color: #555;
            margin: 4px 0;
            font-size: 0.85em;
        }

        .help-section {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            padding: 12px;
            margin-top: 15px;
            border-radius: 5px;
            font-size: 0.8em;
        }

        .help-section h5 {
            margin-bottom: 8px;
            color: #1565c0;
            font-size: 0.9em;
            font-weight: 600;
        }

        .help-item {
            margin: 6px 0;
            padding-left: 10px;
            color: #424242;
            line-height: 1.4;
        }

        .help-item strong {
            color: #1565c0;
        }

        @media (max-width: 1200px) {
            .main-layout {
                grid-template-columns: 1fr;
            }

            .left-panel {
                order: 2;
            }

            .simulators-grid {
                order: 1;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Couleurs tr√®s distinctes (SANS ROUGE pour √©viter confusion avec deadlines)
        const COLORS = [
            '#0000FF',  // Bleu pur
            '#00AA00',  // Vert fonc√©
            '#FF00FF',  // Magenta
            '#00CCCC',  // Cyan
            '#FF8800',  // Orange vif
            '#8800FF',  // Violet
            '#FFD700',  // Or/Jaune
        ];

        const generateTasks = (numTasks, forceOverload = false, forceUnderload = false, constrainedDeadlines = false) => {
            const tasks = [];
            const usedColors = new Set();
            
            for (let i = 0; i < numTasks; i++) {
                let color = COLORS[i % COLORS.length];

                let executionTime, period;
                
                // Cr√©er un MIX de t√¢ches longues et courtes pour maximiser les pr√©emptions
                // Les t√¢ches longues seront souvent interrompues par les courtes
                const isLongTask = i % 2 === 0; // Alterner t√¢ches longues/courtes
                
                if (forceOverload) {
                    // Surcharge avec mix long/court
                    if (isLongTask) {
                        executionTime = Math.floor(Math.random() * 3) + 5; // 5-7 (LONG)
                        period = Math.floor(Math.random() * 3) + executionTime + 2; // P√©riode courte
                    } else {
                        executionTime = Math.floor(Math.random() * 2) + 1; // 1-2 (COURT)
                        period = Math.floor(Math.random() * 3) + executionTime + 3; // P√©riode moyenne
                    }
                } else if (forceUnderload) {
                    // Ordonnan√ßable avec mix long/court
                    if (isLongTask) {
                        executionTime = Math.floor(Math.random() * 2) + 4; // 4-5 (LONG)
                        period = Math.floor(Math.random() * 8) + executionTime + 6; // P√©riode longue
                    } else {
                        executionTime = Math.floor(Math.random() * 2) + 1; // 1-2 (COURT)
                        period = Math.floor(Math.random() * 6) + executionTime + 4; // P√©riode moyenne
                    }
                } else {
                    // Configuration normale avec BEAUCOUP de variation
                    if (isLongTask) {
                        executionTime = Math.floor(Math.random() * 3) + 4; // 4-6 (LONG)
                        period = Math.floor(Math.random() * 5) + executionTime + 4; // 8-15
                    } else {
                        executionTime = Math.floor(Math.random() * 2) + 1; // 1-2 (COURT)
                        period = Math.floor(Math.random() * 4) + executionTime + 3; // 4-9
                    }
                }
                
                // Arriv√©es √©chelonn√©es pour cr√©er des conflits
                const firstArrival = Math.floor(Math.random() * 3);
                
                // Deadline : D = T (implicite) ou D < T (contrainte)
                let relativeDeadline;
                if (constrainedDeadlines) {
                    // D entre 60% et 95% de T (plus r√©aliste, plus contraignant)
                    relativeDeadline = Math.floor(period * (0.6 + Math.random() * 0.35));
                } else {
                    // D = T (deadline implicite, cas classique)
                    relativeDeadline = period;
                }
                
                // Priorit√© : 1 = la plus haute, numTasks = la plus basse
                const priority = i + 1;

                tasks.push({
                    id: i,
                    name: `œÑ${i + 1}`,
                    color,
                    executionTime,
                    period,
                    relativeDeadline,
                    priority,
                    firstArrival,
                });
            }
            
            return tasks.sort((a, b) => a.firstArrival - b.firstArrival);
        };

        const generateJobs = (task, maxTime) => {
            const jobs = [];
            let arrivalTime = task.firstArrival;
            let jobIndex = 0;
            
            while (arrivalTime < maxTime) {
                jobs.push({
                    taskId: task.id,
                    taskName: task.name,
                    jobIndex,
                    color: task.color,
                    arrivalTime,
                    executionTime: task.executionTime,
                    deadline: arrivalTime + task.relativeDeadline,
                    priority: task.priority,
                });
                
                arrivalTime += task.period;
                jobIndex++;
            }
            
            return jobs;
        };

        const calculateUtilization = (tasks) => {
            return tasks.reduce((sum, task) => sum + (task.executionTime / task.period), 0);
        };

        const calculateSchedulabilityBounds = (tasks) => {
            const n = tasks.length;
            const U = calculateUtilization(tasks);
            
            // Fixed Priority (Rate Monotonic): U_RM = n(2^(1/n) - 1)
            const rmBound = n * (Math.pow(2, 1/n) - 1);
            
            // EDF avec deadlines implicites (D = T): U_EDF = 1.0
            // EDF avec deadlines contraintes (D ‚â§ T): plus complexe, utilisons le test de densit√©
            const hasConstrainedDeadlines = tasks.some(t => t.relativeDeadline < t.period);
            
            let edfBound;
            if (hasConstrainedDeadlines) {
                // Test de densit√©: Œî = sum(Ci/Di) ‚â§ 1
                const density = tasks.reduce((sum, task) => 
                    sum + (task.executionTime / task.relativeDeadline), 0
                );
                edfBound = 1.0; // La borne th√©orique reste 1.0, mais on utilise la densit√©
                return {
                    fixedPriority: {
                        bound: rmBound,
                        schedulable: U <= rmBound,
                        utilization: U,
                        name: 'Rate Monotonic (RM)'
                    },
                    sjf: {
                        bound: 1.0,
                        schedulable: U <= 1.0,
                        utilization: U,
                        name: 'SJF Pr√©emptif (SRTF)'
                    },
                    edf: {
                        bound: edfBound,
                        schedulable: density <= 1.0,
                        utilization: U,
                        density: density,
                        name: 'EDF',
                        hasConstrainedDeadlines: true
                    }
                };
            } else {
                // Deadlines implicites (D = T)
                edfBound = 1.0;
                return {
                    fixedPriority: {
                        bound: rmBound,
                        schedulable: U <= rmBound,
                        utilization: U,
                        name: 'Rate Monotonic (RM)'
                    },
                    sjf: {
                        bound: 1.0,
                        schedulable: U <= 1.0,
                        utilization: U,
                        name: 'SJF Pr√©emptif (SRTF)'
                    },
                    edf: {
                        bound: edfBound,
                        schedulable: U <= 1.0,
                        utilization: U,
                        name: 'EDF',
                        hasConstrainedDeadlines: false
                    }
                };
            }
        };

        const GanttChart = ({ task, jobs, currentTime, maxTime, executingJobId, jobStates }) => {
            const gridColumns = Math.ceil(maxTime);
            
            return (
                <div className="gantt-chart">
                    <div className="gantt-row">
                        <div className="task-label">{task.name}</div>
                        <div 
                            className="timeline-area" 
                            style={{ '--grid-columns': gridColumns }}
                        >
                            {jobs.map(job => {
                                const jobKey = `${job.taskId}-${job.jobIndex}`;
                                const jobState = jobStates[jobKey];
                                const isExecuting = executingJobId === jobKey;
                                
                                return (
                                    <React.Fragment key={jobKey}>
                                        {/* Afficher chaque segment d'ex√©cution s√©par√©ment */}
                                        {jobState && jobState.segments && jobState.segments.map((segment, idx) => {
                                            const isLastSegment = idx === jobState.segments.length - 1;
                                            const isFirstSegment = idx === 0;
                                            const isPreempted = !isLastSegment;
                                            const isResumed = !isFirstSegment;
                                            
                                            const segmentStart = segment.startTime;
                                            const segmentEnd = segment.startTime + segment.duration;
                                            
                                            // V√©rifier si ce segment d√©passe la deadline
                                            const startsAfterDeadline = segmentStart >= job.deadline;
                                            const endsAfterDeadline = segmentEnd > job.deadline;
                                            const crossesDeadline = segmentStart < job.deadline && segmentEnd > job.deadline;
                                            
                                            // Calculer les parties avant et apr√®s la deadline
                                            let beforeDeadlinePart = null;
                                            let afterDeadlinePart = null;
                                            
                                            if (startsAfterDeadline) {
                                                // Tout le segment est apr√®s la deadline = tout rouge
                                                afterDeadlinePart = {
                                                    start: segmentStart,
                                                    duration: segment.duration
                                                };
                                            } else if (crossesDeadline) {
                                                // Le segment croise la deadline = partie avant (normale) + partie apr√®s (rouge)
                                                beforeDeadlinePart = {
                                                    start: segmentStart,
                                                    duration: job.deadline - segmentStart
                                                };
                                                afterDeadlinePart = {
                                                    start: job.deadline,
                                                    duration: segmentEnd - job.deadline
                                                };
                                            } else {
                                                // Tout le segment est avant la deadline = normal
                                                beforeDeadlinePart = {
                                                    start: segmentStart,
                                                    duration: segment.duration
                                                };
                                            }
                                            
                                            return (
                                                <React.Fragment key={`${jobKey}-seg-${idx}`}>
                                                    {/* Partie avant la deadline (couleur normale) */}
                                                    {beforeDeadlinePart && beforeDeadlinePart.duration > 0 && (
                                                        <div
                                                            className={`task-block 
                                                                ${isExecuting && isLastSegment && !crossesDeadline ? 'executing' : ''} 
                                                                ${isPreempted ? 'preempted' : ''}
                                                                ${isResumed ? 'resumed' : ''}`}
                                                            style={{
                                                                left: `${(beforeDeadlinePart.start / maxTime) * 100}%`,
                                                                width: `${(beforeDeadlinePart.duration / maxTime) * 100}%`,
                                                                backgroundColor: job.color,
                                                                '--task-color': job.color
                                                            }}
                                                        >
                                                            {isExecuting && isLastSegment && !crossesDeadline && '‚ö°'}
                                                        </div>
                                                    )}
                                                    
                                                    {/* Partie apr√®s la deadline (ROUGE) */}
                                                    {afterDeadlinePart && afterDeadlinePart.duration > 0 && (
                                                        <div
                                                            className={`task-block 
                                                                ${isExecuting && isLastSegment ? 'executing' : ''}`}
                                                            style={{
                                                                left: `${(afterDeadlinePart.start / maxTime) * 100}%`,
                                                                width: `${(afterDeadlinePart.duration / maxTime) * 100}%`,
                                                                backgroundColor: '#dc3545',
                                                                border: '2px solid #c62828',
                                                                '--task-color': '#dc3545'
                                                            }}
                                                        >
                                                            {isExecuting && isLastSegment && '‚ö°'}
                                                            {!isExecuting && isLastSegment && '‚úï'}
                                                        </div>
                                                    )}
                                                    
                                                    {/* Indicateur de pr√©emption entre segments */}
                                                    {isPreempted && (
                                                        <div 
                                                            className="preemption-indicator"
                                                            style={{ 
                                                                left: `${((segment.startTime + segment.duration) / maxTime) * 100}%` 
                                                            }}
                                                            title="Pr√©emption : t√¢che interrompue"
                                                        />
                                                    )}
                                                </React.Fragment>
                                            );
                                        })}
                                        
                                        {/* Marqueur de p√©riode (noir, fl√®che vers le haut) */}
                                        {job.arrivalTime <= maxTime && (
                                            <div 
                                                className="period-marker"
                                                style={{ left: `${(job.arrivalTime / maxTime) * 100}%` }}
                                                title={`Arriv√©e (P√©riode): ${job.arrivalTime}`}
                                            />
                                        )}
                                        {/* Marqueur de deadline (rouge, fl√®che vers le bas) */}
                                        {job.deadline <= maxTime && (
                                            <div 
                                                className="deadline-marker"
                                                style={{ left: `${(job.deadline / maxTime) * 100}%` }}
                                                title={`Deadline: ${job.deadline}`}
                                            />
                                        )}
                                    </React.Fragment>
                                );
                            })}
                            {currentTime > 0 && (
                                <div 
                                    className="time-marker"
                                    style={{ left: `${(currentTime / maxTime) * 100}%` }}
                                />
                            )}
                        </div>
                    </div>
                    <div className="time-axis">
                        <div className="time-label-spacer" />
                        <div className="time-labels">
                            {Array.from({ length: gridColumns + 1 }, (_, i) => (
                                <div key={i} className="time-tick">
                                    {i}
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        const Simulator = ({ title, tasks, allJobs, currentTime, maxTime, executingJobId, jobStates }) => {
            const calculateStats = () => {
                let jobsCompleted = 0;
                let missedDeadlines = 0;
                let waiting = 0;

                allJobs.forEach(job => {
                    const jobKey = `${job.taskId}-${job.jobIndex}`;
                    const state = jobStates[jobKey];
                    
                    if (state && state.segments && state.segments.length > 0) {
                        // V√©rifier si n'importe quel segment d√©passe la deadline
                        const hasMissedDeadline = state.segments.some(segment => {
                            const segmentEnd = segment.startTime + segment.duration;
                            return segmentEnd > job.deadline;
                        });
                        
                        if (hasMissedDeadline) {
                            missedDeadlines++;
                        }
                        
                        if (state.completed) {
                            jobsCompleted++;
                        }
                    }
                    
                    if (state && job.arrivalTime <= currentTime && state.remainingTime > 0) {
                        waiting++;
                    }
                });

                return { jobsCompleted, totalJobs: allJobs.length, missedDeadlines, waiting };
            };

            const stats = calculateStats();

            return (
                <div className="simulator-container">
                    <h2 className="simulator-title">{title}</h2>
                    {tasks.map(task => {
                        const taskJobs = allJobs.filter(j => j.taskId === task.id);
                        return (
                            <GanttChart 
                                key={task.id}
                                task={task}
                                jobs={taskJobs}
                                currentTime={currentTime}
                                maxTime={maxTime}
                                executingJobId={executingJobId}
                                jobStates={jobStates}
                            />
                        );
                    })}
                    <div className="stats-section">
                        <div className="stat-item">
                            <div className="stat-label">Jobs termin√©s</div>
                            <div className="stat-value">{stats.jobsCompleted}/{stats.totalJobs}</div>
                        </div>
                        <div className="stat-item">
                            <div className="stat-label">En attente</div>
                            <div className="stat-value">{stats.waiting}</div>
                        </div>
                        <div className="stat-item">
                            <div className="stat-label">Deadlines rat√©es</div>
                            <div className="stat-value" style={{ color: stats.missedDeadlines > 0 ? '#e74c3c' : '#27ae60' }}>
                                {stats.missedDeadlines}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [numTasks, setNumTasks] = useState(4);
            const [forceOverload, setForceOverload] = useState(false);
            const [forceUnderload, setForceUnderload] = useState(false);
            const [constrainedDeadlines, setConstrainedDeadlines] = useState(true);
            const [tasks, setTasks] = useState([]);
            const [allJobs, setAllJobs] = useState([]);
            const [isRunning, setIsRunning] = useState(false);
            const [isPaused, setIsPaused] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [explanation, setExplanation] = useState('');
            
            const [fpState, setFpState] = useState({ jobStates: {}, executingJobId: null });
            const [sjfState, setSjfState] = useState({ jobStates: {}, executingJobId: null });
            const [edfState, setEdfState] = useState({ jobStates: {}, executingJobId: null });
            
            const intervalRef = useRef(null);
            const maxTime = 40;

            const initializeJobStates = (jobs) => {
                const states = {};
                jobs.forEach(job => {
                    const jobKey = `${job.taskId}-${job.jobIndex}`;
                    states[jobKey] = {
                        startTime: null,
                        progress: 0,
                        remainingTime: job.executionTime,
                        completed: false,
                        segments: [], // Pour tracker les segments d'ex√©cution
                        wasPreempted: false
                    };
                });
                return states;
            };

            const selectJobFP = (jobs, jobStates, currentTime) => {
                const availableJobs = jobs.filter(j => {
                    const jobKey = `${j.taskId}-${j.jobIndex}`;
                    return j.arrivalTime <= currentTime && !jobStates[jobKey].completed;
                });
                
                if (availableJobs.length === 0) return null;
                
                // Plus petit num√©ro = plus haute priorit√©
                return availableJobs.reduce((prev, curr) => 
                    prev.priority < curr.priority ? prev : curr
                );
            };

            const selectJobSJF = (jobs, jobStates, currentTime) => {
                const availableJobs = jobs.filter(j => {
                    const jobKey = `${j.taskId}-${j.jobIndex}`;
                    return j.arrivalTime <= currentTime && jobStates[jobKey].remainingTime > 0;
                });
                
                if (availableJobs.length === 0) return null;
                
                return availableJobs.reduce((prev, curr) => {
                    const prevKey = `${prev.taskId}-${prev.jobIndex}`;
                    const currKey = `${curr.taskId}-${curr.jobIndex}`;
                    return jobStates[prevKey].remainingTime < jobStates[currKey].remainingTime ? prev : curr;
                });
            };

            const selectJobEDF = (jobs, jobStates, currentTime) => {
                const availableJobs = jobs.filter(j => {
                    const jobKey = `${j.taskId}-${j.jobIndex}`;
                    return j.arrivalTime <= currentTime && jobStates[jobKey].remainingTime > 0;
                });
                
                if (availableJobs.length === 0) return null;
                
                return availableJobs.reduce((prev, curr) => 
                    prev.deadline < curr.deadline ? prev : curr
                );
            };

            const updateJobState = (jobStates, executingJob, currentTime, timeStep, previousExecutingJobId) => {
                if (!executingJob) {
                    return { jobStates, executingJobId: null };
                }

                const newJobStates = { ...jobStates };
                const jobKey = `${executingJob.taskId}-${executingJob.jobIndex}`;
                const state = { ...newJobStates[jobKey] };

                // D√©tecter si c'est un nouveau segment (d√©marrage ou reprise apr√®s pr√©emption)
                const isNewSegment = state.startTime === null || 
                                    (previousExecutingJobId !== null && previousExecutingJobId !== jobKey);

                if (state.startTime === null) {
                    state.startTime = currentTime;
                }

                // Si c'est un nouveau segment d'ex√©cution
                if (isNewSegment) {
                    state.segments.push({
                        startTime: currentTime,
                        duration: 0
                    });
                    
                    // Si ce n'est pas le premier segment, c'est une reprise apr√®s pr√©emption
                    if (state.segments.length > 1) {
                        state.wasPreempted = true;
                    }
                }

                const timeToExecute = Math.min(timeStep, state.remainingTime);
                state.progress += timeToExecute;
                state.remainingTime -= timeToExecute;

                // Mettre √† jour la dur√©e du segment actuel
                if (state.segments.length > 0) {
                    state.segments[state.segments.length - 1].duration += timeToExecute;
                }

                if (state.remainingTime <= 0) {
                    state.completed = true;
                }

                newJobStates[jobKey] = state;

                // Marquer l'ancien job comme pr√©empt√© si on change de job
                if (previousExecutingJobId && previousExecutingJobId !== jobKey && newJobStates[previousExecutingJobId]) {
                    const prevState = { ...newJobStates[previousExecutingJobId] };
                    if (!prevState.completed) {
                        prevState.wasPreempted = true;
                    }
                    newJobStates[previousExecutingJobId] = prevState;
                }

                return {
                    jobStates: newJobStates,
                    executingJobId: jobKey
                };
            };

            const generateSimulation = () => {
                const newTasks = generateTasks(Math.max(3, Math.min(7, numTasks)), forceOverload, forceUnderload, constrainedDeadlines);
                setTasks(newTasks);
                
                const jobs = [];
                newTasks.forEach(task => {
                    const taskJobs = generateJobs(task, maxTime);
                    jobs.push(...taskJobs);
                });
                setAllJobs(jobs);
                
                setFpState({ jobStates: initializeJobStates(jobs), executingJobId: null });
                setSjfState({ jobStates: initializeJobStates(jobs), executingJobId: null });
                setEdfState({ jobStates: initializeJobStates(jobs), executingJobId: null });

                setCurrentTime(0);
                setIsRunning(false);
                setIsPaused(false);
                setExplanation('');
            };

            const startSimulation = () => {
                if (tasks.length === 0) {
                    generateSimulation();
                }
                setIsRunning(true);
                setIsPaused(false);
            };

            const pauseSimulation = () => {
                setIsPaused(true);
                
                const fpJob = allJobs.find(j => `${j.taskId}-${j.jobIndex}` === fpState.executingJobId);
                const sjfJob = allJobs.find(j => `${j.taskId}-${j.jobIndex}` === sjfState.executingJobId);
                const edfJob = allJobs.find(j => `${j.taskId}-${j.jobIndex}` === edfState.executingJobId);

                let exp = `‚è∏ Simulation en pause √† t = ${currentTime.toFixed(1)}\n\n`;
                
                const availableJobs = allJobs.filter(j => j.arrivalTime <= currentTime);
                const availableList = availableJobs.slice(0, 5).map(j => `${j.taskName}.${j.jobIndex}`).join(', ');
                exp += `üìã Jobs disponibles : ${availableList}${availableJobs.length > 5 ? '...' : ''}\n\n`;
                
                if (fpJob) {
                    const fpJobKey = `${fpJob.taskId}-${fpJob.jobIndex}`;
                    const fpProgress = fpState.jobStates[fpJobKey].progress;
                    exp += `üîµ FIXED PRIORITY (Non-Preemptive) :\n`;
                    exp += `   ${fpJob.taskName}.${fpJob.jobIndex} (Priorit√©: ${fpJob.priority})\n`;
                    exp += `   Progression: ${fpProgress.toFixed(1)}/${fpJob.executionTime} | Deadline: ${fpJob.deadline}\n\n`;
                } else {
                    exp += `üîµ FIXED PRIORITY : Inactif\n\n`;
                }
                
                if (sjfJob) {
                    const sjfJobKey = `${sjfJob.taskId}-${sjfJob.jobIndex}`;
                    const sjfRemaining = sjfState.jobStates[sjfJobKey].remainingTime;
                    exp += `üü¢ SJF PREEMPTIVE (SRTF) :\n`;
                    exp += `   ${sjfJob.taskName}.${sjfJob.jobIndex} (Restant: ${sjfRemaining.toFixed(1)})\n\n`;
                } else {
                    exp += `üü¢ SJF PREEMPTIVE : Inactif\n\n`;
                }
                
                if (edfJob) {
                    const edfJobKey = `${edfJob.taskId}-${edfJob.jobIndex}`;
                    const edfRemaining = edfState.jobStates[edfJobKey].remainingTime;
                    exp += `üü£ EDF (Earliest Deadline First) :\n`;
                    exp += `   ${edfJob.taskName}.${edfJob.jobIndex} (Deadline: ${edfJob.deadline})`;
                } else {
                    exp += `üü£ EDF : Inactif`;
                }

                setExplanation(exp);
            };

            const resumeSimulation = () => {
                setIsPaused(false);
                setExplanation('');
            };

            const stopSimulation = () => {
                setIsRunning(false);
                setIsPaused(false);
                setCurrentTime(0);
                setExplanation('');
                if (allJobs.length > 0) {
                    setFpState({ jobStates: initializeJobStates(allJobs), executingJobId: null });
                    setSjfState({ jobStates: initializeJobStates(allJobs), executingJobId: null });
                    setEdfState({ jobStates: initializeJobStates(allJobs), executingJobId: null });
                }
            };

            useEffect(() => {
                if (isRunning && !isPaused && allJobs.length > 0) {
                    intervalRef.current = setInterval(() => {
                        setCurrentTime(prev => {
                            if (prev >= maxTime) {
                                setIsRunning(false);
                                return maxTime;
                            }
                            
                            const newTime = prev + 0.05; // R√©duit de 0.15 √† 0.05 pour plus de v√©rifications
                            
                            setFpState(prevState => {
                                const selectedJob = selectJobFP(allJobs, prevState.jobStates, newTime);
                                const jobToExecute = prevState.executingJobId && 
                                                     prevState.jobStates[prevState.executingJobId] &&
                                                     !prevState.jobStates[prevState.executingJobId].completed
                                    ? allJobs.find(j => `${j.taskId}-${j.jobIndex}` === prevState.executingJobId)
                                    : selectedJob;
                                return updateJobState(prevState.jobStates, jobToExecute, newTime, 0.05, prevState.executingJobId);
                            });

                            setSjfState(prevState => {
                                const selectedJob = selectJobSJF(allJobs, prevState.jobStates, newTime);
                                return updateJobState(prevState.jobStates, selectedJob, newTime, 0.05, prevState.executingJobId);
                            });

                            setEdfState(prevState => {
                                const selectedJob = selectJobEDF(allJobs, prevState.jobStates, newTime);
                                return updateJobState(prevState.jobStates, selectedJob, newTime, 0.05, prevState.executingJobId);
                            });

                            return newTime;
                        });
                    }, 50); // R√©duit de 100ms √† 50ms pour animation plus fluide
                } else {
                    if (intervalRef.current) {
                        clearInterval(intervalRef.current);
                    }
                }

                return () => {
                    if (intervalRef.current) {
                        clearInterval(intervalRef.current);
                    }
                };
            }, [isRunning, isPaused, allJobs]);

            const utilization = tasks.length > 0 ? calculateUtilization(tasks) : 0;
            const schedulabilityBounds = tasks.length > 0 ? calculateSchedulabilityBounds(tasks) : null;

            return (
                <div className="container">
                    <h1>Simulateur d'Algorithmes d'Ordonnancement Temps R√©el</h1>
                    <p className="subtitle">
                        T√¢ches P√©riodiques - Comparaison Fixed Priority, SJF Preemptive et EDF
                    </p>

                    {isPaused && explanation && (
                        <div className="explanation-panel">
                            <h4>Analyse de l'√âtat Actuel</h4>
                            <p style={{ whiteSpace: 'pre-line' }}>{explanation}</p>
                        </div>
                    )}

                    <div className="main-layout">
                        <div className="left-panel">
                            {tasks.length > 0 && (
                                <>
                                    <div className={`utilization-info ${utilization > 1 ? 'overload' : ''}`}>
                                        <div style={{ fontSize: '0.85em', marginBottom: '5px' }}>
                                            Utilisation du processeur (U)
                                        </div>
                                        <div className="utilization-value">
                                            {(utilization * 100).toFixed(1)}%
                                        </div>
                                        {utilization > 1 && (
                                            <div style={{ fontSize: '0.8em', marginTop: '5px', color: '#c62828' }}>
                                                ‚ö†Ô∏è Syst√®me en surcharge ! (U &gt; 100%)
                                            </div>
                                        )}
                                    </div>

                                    {schedulabilityBounds && (
                                        <div className="schedulability-bounds">
                                            <h4 style={{ fontSize: '0.9em', marginBottom: '8px', color: '#2c3e50' }}>
                                                Bornes d'Ordonnan√ßabilit√©
                                            </h4>
                                            
                                            <div style={{ fontSize: '0.75em', marginBottom: '8px' }}>
                                                <div style={{ 
                                                    padding: '6px', 
                                                    background: schedulabilityBounds.fixedPriority.schedulable ? '#d4edda' : '#f8d7da',
                                                    border: `1px solid ${schedulabilityBounds.fixedPriority.schedulable ? '#c3e6cb' : '#f5c6cb'}`,
                                                    borderRadius: '3px',
                                                    marginBottom: '5px'
                                                }}>
                                                    <strong>Fixed Priority (RM):</strong>
                                                    <div>Plafond: {(schedulabilityBounds.fixedPriority.bound * 100).toFixed(1)}% (n={tasks.length})</div>
                                                    <div style={{ color: schedulabilityBounds.fixedPriority.schedulable ? '#155724' : '#721c24' }}>
                                                        {schedulabilityBounds.fixedPriority.schedulable ? '‚úì Ordonnan√ßable' : '‚úó Non garanti'}
                                                    </div>
                                                </div>
                                                
                                                <div style={{ 
                                                    padding: '6px', 
                                                    background: schedulabilityBounds.sjf.schedulable ? '#d4edda' : '#f8d7da',
                                                    border: `1px solid ${schedulabilityBounds.sjf.schedulable ? '#c3e6cb' : '#f5c6cb'}`,
                                                    borderRadius: '3px',
                                                    marginBottom: '5px'
                                                }}>
                                                    <strong>SJF Pr√©emptif:</strong>
                                                    <div>Plafond: {(schedulabilityBounds.sjf.bound * 100).toFixed(1)}%</div>
                                                    <div style={{ color: schedulabilityBounds.sjf.schedulable ? '#155724' : '#721c24' }}>
                                                        {schedulabilityBounds.sjf.schedulable ? '‚úì Ordonnan√ßable' : '‚úó Non ordonnan√ßable'}
                                                    </div>
                                                </div>
                                                
                                                <div style={{ 
                                                    padding: '6px', 
                                                    background: schedulabilityBounds.edf.schedulable ? '#d4edda' : '#f8d7da',
                                                    border: `1px solid ${schedulabilityBounds.edf.schedulable ? '#c3e6cb' : '#f5c6cb'}`,
                                                    borderRadius: '3px'
                                                }}>
                                                    <strong>EDF:</strong>
                                                    <div>Plafond: {(schedulabilityBounds.edf.bound * 100).toFixed(1)}%</div>
                                                    {schedulabilityBounds.edf.hasConstrainedDeadlines && (
                                                        <div style={{ fontSize: '0.9em', color: '#856404' }}>
                                                            Densit√© (Œî): {(schedulabilityBounds.edf.density * 100).toFixed(1)}%
                                                        </div>
                                                    )}
                                                    <div style={{ color: schedulabilityBounds.edf.schedulable ? '#155724' : '#721c24' }}>
                                                        {schedulabilityBounds.edf.schedulable ? '‚úì Ordonnan√ßable' : '‚úó Non ordonnan√ßable'}
                                                    </div>
                                                    {schedulabilityBounds.edf.hasConstrainedDeadlines && !schedulabilityBounds.edf.schedulable && (
                                                        <div style={{ fontSize: '0.85em', marginTop: '3px', color: '#c62828' }}>
                                                            ‚ö†Ô∏è D &lt; T : Œî &gt; 1
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    )}

                                    <div className="tasks-info">
                                        <h3>T√¢ches P√©riodiques G√©n√©r√©es</h3>
                                        {tasks.map(task => {
                                            const taskJobs = allJobs.filter(j => j.taskId === task.id);
                                            return (
                                                <div 
                                                    key={task.id}
                                                    className="task-card"
                                                    style={{ borderLeftColor: task.color }}
                                                >
                                                    <div className="task-name" style={{ color: task.color }}>
                                                        {task.name} ({taskJobs.length} jobs) {task.executionTime >= 4 ? '‚è±Ô∏è Longue' : '‚ö° Courte'}
                                                    </div>
                                                    <div className="task-detail">
                                                        <strong>Exec:</strong> {task.executionTime} | <strong>P√©riode:</strong> {task.period} | <strong>Deadline:</strong> {task.relativeDeadline} {task.relativeDeadline < task.period && '‚ö†Ô∏è'}
                                                    </div>
                                                    <div className="task-detail">
                                                        <strong>Priorit√©:</strong> {task.priority} {task.priority === Math.min(...tasks.map(t => t.priority)) && '(la plus haute)'} {task.priority === Math.max(...tasks.map(t => t.priority)) && '(la plus basse)'} | <strong>1√®re arriv√©e:</strong> {task.firstArrival}
                                                    </div>
                                                    <div className="task-detail">
                                                        <strong>Utilisation:</strong> {((task.executionTime / task.period) * 100).toFixed(1)}% | <strong>D/T:</strong> {((task.relativeDeadline / task.period) * 100).toFixed(0)}%
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>

                                    <div className="legend">
                                        <h4>L√©gende</h4>
                                        <div className="legend-items">
                                            {tasks.map(task => (
                                                <div key={task.id} className="legend-item">
                                                    <span 
                                                        className="legend-color"
                                                        style={{ backgroundColor: task.color }}
                                                    />
                                                    <span>{task.name}</span>
                                                </div>
                                            ))}
                                            <div className="legend-item">
                                                <span style={{ 
                                                    width: '25px', 
                                                    height: '15px', 
                                                    background: 'black',
                                                    display: 'inline-block',
                                                    position: 'relative'
                                                }}>
                                                    <span style={{
                                                        position: 'absolute',
                                                        top: '-3px',
                                                        left: '9px',
                                                        width: 0,
                                                        height: 0,
                                                        borderLeft: '3px solid transparent',
                                                        borderRight: '3px solid transparent',
                                                        borderTop: '6px solid black'
                                                    }} />
                                                </span>
                                                <span>P√©riode (arriv√©e job)</span>
                                            </div>
                                            <div className="legend-item">
                                                <span style={{ 
                                                    width: '25px', 
                                                    height: '15px', 
                                                    background: 'red',
                                                    display: 'inline-block',
                                                    position: 'relative'
                                                }}>
                                                    <span style={{
                                                        position: 'absolute',
                                                        bottom: '-3px',
                                                        left: '9px',
                                                        width: 0,
                                                        height: 0,
                                                        borderLeft: '3px solid transparent',
                                                        borderRight: '3px solid transparent',
                                                        borderBottom: '6px solid red'
                                                    }} />
                                                </span>
                                                <span>Deadline (‚ñº)</span>
                                            </div>
                                            <div className="legend-item">
                                                <span style={{ 
                                                    width: '25px', 
                                                    height: '15px', 
                                                    background: 'red'
                                                }} />
                                                <span>Temps actuel (ligne)</span>
                                            </div>
                                            <div className="legend-item">
                                                <span style={{ 
                                                    width: '25px', 
                                                    height: '15px', 
                                                    background: '#dc3545',
                                                    border: '2px solid #c62828'
                                                }} />
                                                <span>Deadline rat√©e (ex√©cution apr√®s ‚ñº)</span>
                                            </div>
                                            <div className="legend-item">
                                                <span style={{ 
                                                    width: '25px', 
                                                    height: '15px', 
                                                    background: '#ff9800',
                                                    position: 'relative'
                                                }}>
                                                    <span style={{
                                                        position: 'absolute',
                                                        top: '50%',
                                                        left: '50%',
                                                        transform: 'translate(-50%, -50%)',
                                                        color: 'white',
                                                        fontSize: '1.2em',
                                                        fontWeight: 'bold'
                                                    }}>‚äó</span>
                                                </span>
                                                <span>Pr√©emption (t√¢che interrompue)</span>
                                            </div>
                                        </div>
                                    </div>
                                </>
                            )}
                            
                            <div className="controls-section">
                                <div className="control-row">
                                    <div className="control-group">
                                        <label>Nombre de t√¢ches :</label>
                                        <input
                                            type="number"
                                            min="3"
                                            max="7"
                                            value={numTasks}
                                            onChange={(e) => setNumTasks(parseInt(e.target.value))}
                                            disabled={isRunning}
                                        />
                                    </div>
                                    
                                    <div className="checkbox-group" style={{ background: '#e3f2fd', borderColor: '#2196f3' }}>
                                        <input
                                            type="checkbox"
                                            id="constrained"
                                            checked={constrainedDeadlines}
                                            onChange={(e) => setConstrainedDeadlines(e.target.checked)}
                                            disabled={isRunning}
                                        />
                                        <label htmlFor="constrained" style={{ color: '#1565c0' }}>
                                            üìå Deadlines contraintes (D &lt; T)
                                        </label>
                                    </div>
                                    
                                    <div className="checkbox-group" style={{ background: '#d4edda', borderColor: '#28a745' }}>
                                        <input
                                            type="checkbox"
                                            id="underload"
                                            checked={forceUnderload}
                                            onChange={(e) => {
                                                setForceUnderload(e.target.checked);
                                                if (e.target.checked) setForceOverload(false);
                                            }}
                                            disabled={isRunning}
                                        />
                                        <label htmlFor="underload" style={{ color: '#155724' }}>
                                            ‚úÖ Forcer U &lt; 1 (syst√®me ordonnan√ßable)
                                        </label>
                                    </div>
                                    
                                    <div className="checkbox-group">
                                        <input
                                            type="checkbox"
                                            id="overload"
                                            checked={forceOverload}
                                            onChange={(e) => {
                                                setForceOverload(e.target.checked);
                                                if (e.target.checked) setForceUnderload(false);
                                            }}
                                            disabled={isRunning}
                                        />
                                        <label htmlFor="overload">
                                            ‚ö†Ô∏è Forcer U &gt; 1 (surcharge - Effet domino EDF)
                                        </label>
                                    </div>
                                    
                                    <div className="help-section">
                                        <h5>‚ÑπÔ∏è Guide des Options</h5>
                                        <div className="help-item">
                                            <strong>üìå D &lt; T :</strong> Deadlines plus strictes (60-95% de la p√©riode). Plus r√©aliste pour syst√®mes critiques. Rend l'ordonnancement plus difficile.
                                        </div>
                                        <div className="help-item">
                                            <strong>‚úÖ U &lt; 1 :</strong> Garantit un syst√®me ordonnan√ßable pour SJF et EDF avec D=T. Pour Fixed Priority, la borne est plus basse (plafond RM).
                                        </div>
                                        <div className="help-item">
                                            <strong>‚ö†Ô∏è U &gt; 1 :</strong> Surcharge intentionnelle. Provoque l'effet domino sur EDF o√π toutes les t√¢ches finissent par rater leurs deadlines.
                                        </div>
                                        <div className="help-item" style={{ marginTop: '10px', paddingTop: '10px', borderTop: '1px solid #90caf9' }}>
                                            <strong>üîÑ Pr√©emption :</strong> SJF et EDF peuvent interrompre une t√¢che (marqueur orange ‚äó) pour en ex√©cuter une plus urgente. Fixed Priority ne pr√©empte jamais une t√¢che commenc√©e.
                                        </div>
                                        <div className="help-item" style={{ marginTop: '10px', paddingTop: '10px', borderTop: '1px solid #90caf9' }}>
                                            <strong>üìä Bornes d'Ordonnan√ßabilit√© :</strong>
                                            <div style={{ fontSize: '0.9em', marginTop: '5px' }}>
                                                ‚Ä¢ <strong>Fixed Priority (RM):</strong> U ‚â§ n(2^(1/n) - 1) o√π n = nombre de t√¢ches
                                                <br/>‚Ä¢ <strong>SJF/EDF (D=T):</strong> U ‚â§ 1.0 (100%)
                                                <br/>‚Ä¢ <strong>EDF (D&lt;T):</strong> Densit√© Œî = Œ£(Ci/Di) ‚â§ 1.0
                                                <br/><em style={{ color: '#856404' }}>‚ö†Ô∏è Avec D&lt;T, m√™me si U&lt;1, le syst√®me peut √™tre non ordonnan√ßable si Œî&gt;1</em>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div className="button-group">
                                        <button 
                                            className="primary"
                                            onClick={generateSimulation}
                                            disabled={isRunning}
                                        >
                                            G√©n√©rer les t√¢ches
                                        </button>
                                        <button 
                                            className="success"
                                            onClick={startSimulation}
                                            disabled={isRunning || tasks.length === 0}
                                        >
                                            D√©marrer la simulation
                                        </button>
                                        {!isPaused ? (
                                            <button 
                                                className="warning"
                                                onClick={pauseSimulation}
                                                disabled={!isRunning}
                                            >
                                                Pause
                                            </button>
                                        ) : (
                                            <button 
                                                className="success"
                                                onClick={resumeSimulation}
                                            >
                                                Reprendre
                                            </button>
                                        )}
                                        <button 
                                            className="danger"
                                            onClick={stopSimulation}
                                            disabled={!isRunning && !isPaused}
                                        >
                                            Arr√™ter
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className="simulators-grid">
                            {tasks.length > 0 && (
                                <>
                                    <Simulator 
                                        title="Fixed Priority (Non-Preemptive)"
                                        tasks={tasks}
                                        allJobs={allJobs}
                                        currentTime={currentTime}
                                        maxTime={maxTime}
                                        executingJobId={fpState.executingJobId}
                                        jobStates={fpState.jobStates}
                                    />
                                    <Simulator 
                                        title="Shortest Job First (Preemptive - SRTF)"
                                        tasks={tasks}
                                        allJobs={allJobs}
                                        currentTime={currentTime}
                                        maxTime={maxTime}
                                        executingJobId={sjfState.executingJobId}
                                        jobStates={sjfState.jobStates}
                                    />
                                    <Simulator 
                                        title="Earliest Deadline First (EDF)"
                                        tasks={tasks}
                                        allJobs={allJobs}
                                        currentTime={currentTime}
                                        maxTime={maxTime}
                                        executingJobId={edfState.executingJobId}
                                        jobStates={edfState.jobStates}
                                    />
                                </>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
